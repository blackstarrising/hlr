Zunächst wurde mit das Makefile mit -pg dazu gebracht, gprof zu verwenden. Hiermit haben wir dann verschiedene COmpiler-Optionen getestet.

#############################################

Keine Compileroptimierung:
CFLAGS = -std=c11 -pedantic -Wall -Wextra -O0 -pg

Berechnungszeit:    186.154540 s
Each sample counts as 0.01 seconds.
  %   cumulative   self              self     total
  time   seconds   seconds    calls   s/call   s/call  name
  95.83    142.88   142.88        1   142.88   148.84  calculate
  4.00    148.84     5.96 2758256640     0.00     0.00  getResiduum
  0.30    149.29     0.45        1     0.45     0.45  initMatrices
  0.00    149.29     0.00        4     0.00     0.00  allocateMemory
  0.00    149.29     0.00        1     0.00     0.00  AskParams
  0.00    149.29     0.00        1     0.00     0.00  DisplayMatrix
  0.00    149.29     0.00        1     0.00     0.00  allocateMatrices
  0.00    149.29     0.00        1     0.00     0.00  displayStatistics
  0.00    149.29     0.00        1     0.00     0.00  freeMatrices
  0.00    149.29     0.00        1     0.00     0.00  initVariables

Die Funktion calculate benötigt 95.83% der Laufzeit des Programmes mit 142.88 Sekunden bei einem Aufruf. getResiduum braucht insgesamt auch 5.96s, aber nur da es so oft aufgerufen wird (zeit pro Aufruf: 0).

#############################################

Compileroptimierung O1:
CFLAGS = -std=c11 -pedantic -Wall -Wextra -O1 -pg

Berechnungszeit:    152.332796 s
Each sample counts as 0.01 seconds.
  %   cumulative   self              self     total
  time   seconds   seconds    calls  ms/call  ms/call  name
  95.20    108.06   108.06                             main
  4.21    112.84     4.78 2758256640     0.00     0.00  getResiduum
  0.77    113.71     0.87        4   217.89   217.89  allocateMemory
  0.00    113.71     0.00        1     0.00     0.00  AskParams
  0.00    113.71     0.00        1     0.00     0.00  DisplayMatrix


Mit einer Optimierung von O1 wird die Laufzeit, wie erwartet, kürzer. Es wird die meiste Rechenzeit von main eingenommen (vermutlich weil hier nun calculate drinsteckt). Generell sind weniger unterschiedliche aufgerufene Funktionen zu sehen.

#############################################

Compileroptimierung O2:
CFLAGS = -std=c11 -pedantic -Wall -Wextra -O2 -pg

Berechnungszeit:    126.581384 s
Each sample counts as 0.01 seconds.
 no time accumulated
 

Es kann von gprof keine Zeiten mehr gemessen werden. Der Grund hierfür ist, dass der Compiler nun einen langen Maschienencode erzeugt, der nicht mehr in Funktionen unterteilt ist.

#############################################

Compileroptimierung O3:
CFLAGS = -std=c11 -pedantic -Wall -Wextra -O3 -pg

Berechnungszeit:    118.112916 s
  %   cumulative   self              self     total
 time   seconds   seconds    calls  Ts/call  Ts/call  name

Auch hier kann keine Zeitmessung mehr gemacht werden.

#############################################

Compileroptimierung Os:
CFLAGS = -std=c11 -pedantic -Wall -Wextra -Os -pg

Berechnungszeit:    125.636921 s
Each sample counts as 0.01 seconds.
  %   cumulative   self              self     total
 time   seconds   seconds    calls  Ts/call  Ts/call  name
 79.63      3.82     3.82                             getResiduum
 20.69      4.82     0.99                             allocateMemory

Die Option Os erlaubt wieder eine Ueitmessung und hat eine Gesamtlaufzeit die im Bereich der Laufzeit unter der Verwendung von O2 liegt.

#############################################

Insgesamt kann erkannt werden, dass die Funktion calculate die meisten Probleme macht. Aus diesem Grund sollen hier auch die hauptsächlichen Änderungen passieren.

Hier noch eine Ausgabe von perf:

Performance counter stats for './partdiff-seq 1 2 64 1 2 10240':

     144629,659973      task-clock (msec)         #    0,999 CPUs utilized
               477      context-switches          #    0,003 K/sec
                 0      cpu-migrations            #    0,000 K/sec
             1.119      page-faults               #    0,008 K/sec
                 0      cycles                    #    0,000 GHz
   296.299.708.532      stalled-cycles-frontend   #    0,00% frontend cycles idle
   126.512.307.944      stalled-cycles-backend    #    0,00% backend  cycles idle
   477.390.158.665      instructions
                                                  #    0,62  stalled cycles per insn
    22.103.072.466      branches                  #  152,825 M/sec
         8.189.696      branch-misses             #    0,04% of all branches

     144,712383957 seconds time elapsed

TODO: Bedeutung erklären!

Die Änderungen am Programm werden zunächst mit Optimierungsmodus O0 getestet.

Änderung 1: Vertausch von Spalten- und Zeileniteration.
Die Matritzen wurden zunächst Reihen- und dann Spaltenweise durchlaufen. Dies ist konträr zur Definition der Matritzen. Ein vertauschen der Indizes bringt eine Verringerung der Programmlaufzeit:

Berechnungszeit:    106.481083 s
Each sample counts as 0.01 seconds.
  %   cumulative   self              self     total
  time   seconds   seconds    calls   s/call   s/call  name
  90.61     62.68    62.68        1    62.68    68.83  calculate
  8.89     68.83     6.15 2758256640     0.00     0.00  getResiduum
  0.64     69.27     0.44        1     0.44     0.44  initMatrices
  0.00     69.27     0.00        4     0.00     0.00  allocateMemory
  0.00     69.27     0.00        1     0.00     0.00  AskParams
  0.00     69.27     0.00        1     0.00     0.00  DisplayMatrix
  0.00     69.27     0.00        1     0.00     0.00  allocateMatrices
  0.00     69.27     0.00        1     0.00     0.00  displayStatistics
  0.00     69.27     0.00        1     0.00     0.00  freeMatrices
  0.00     69.27     0.00        1     0.00     0.00  initVariables

Calculate nimmt nun mehr 90% der Programmlaufzeit ein, was eine Verbesserung darstellt.

